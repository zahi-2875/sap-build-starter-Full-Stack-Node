'use strict';

/**
 * Normalize a queries `from` clause by moving the infix filters on the last step of a `SELECT.from.ref` path.
 *
 * For the given query/projection, if the terminal ref element is an object
 * containing a `where` (syntactic sugar), its condition is moved into `SELECT.where`.
 * - If `SELECT.where` already exists, both are combined as:  { xpr: [ oldWhere ] } AND { xpr: [ leafWhere ] }.
 * - Otherwise the leaf `where` becomes the `SELECT.where`.
 * The ref leaf object is then replaced by its plain `id`, removing the inline filter.
 *
 * Mutates the provided query in place.
 *
 * @param {CSN.Query} query - The query to normalize.
 */
function normalizeFromLeaf( query ) {
  const where = query.SELECT?.from.ref?.at(-1).where;
  if (!where || where.length === 0)
    return;
  if (query.SELECT.where)
    query.SELECT.where = [ { xpr: [ ...query.SELECT.where ] }, 'AND', { xpr: [ ...where ] } ];
  else
    query.SELECT.where = where;

  // preserve `args`
  if (query.SELECT?.from.ref?.at(-1).args)
    delete query.SELECT.from.ref[query.SELECT.from.ref.length - 1].where;
  else
    query.SELECT.from.ref[query.SELECT.from.ref.length - 1] = query.SELECT.from.ref.at(-1).id;
}


module.exports = normalizeFromLeaf;
